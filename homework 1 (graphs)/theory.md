1. Граф - это математический объект, состоящий из множества вершин и множества рёбер. Каждое ребро есть пара вершин - говорят, что ребро соединяет две вершины между собой
1. В случае простого графа максимальное число ребёр достигается тогда, когда все рёбра соединены между собой по одному разу для неориентированного графа и по два раза (двумя рёбрами с противоположной ориентацией) для ориентированного. Тогда M = N(N-1)/2 и M = N(N-1) соответственно (N - кол-во вершин).
1. У неориентированного графа матрица смежности симметрична относительно главной диагонали, у неориентированного - нет.
1. Для каждого ребра придётся также хранить в памяти его вес. Тогда список рёбер превратится из списка пар смежных вершин в список троек "вершина - вершина - вес", а список смежности - из списка списков вершин, смежных данной, в список списков пар "вершина, смежная данной - вес ребра, их соединяющего"
1. Компонента связности графа - это максимальный связный подграф исходного графа (такой, который нельзя расширить, не теряя связности). Вершина сама по себе считается связным графом. Поэтому минимальное количество компонент - 1 (исходный граф связный), максимальное - N (нет ни одного ребра).
1. Да, можно. Через BFS также можно найти кратчайший цикл, но это займёт дольше. Поэтому если нужно именно проверить наличие циклов, проще использовать DFS
1. Если есть отрицательные веса, то может оказаться, что ранее зафиксированное значение окажется неправильным (т.е. путь "в обход" суммарно весит меньше, хотя начало этого обходного пути весит меньше, чем уже выбранный путь - очевидно, что такое возможно, только если конец этого пути имеет отрицательный вес). В таком случае для сохранения корректности нужно обновить расстояние до этой вершины и пересчитать всё с момента её фиксации
1. В "хорошем" случае за N-1 запусков мы найдём все кратчайшие расстояния, и на N-ном запуске ничего не изменится. В "плохом" случае на N-ном запуске поменялось значение для какой-либо вершины, это значит, что в графе есть цикл с отрицательным суммарным весом. Понятно, что для всех вершин, которые могут уменьшать расстояние до себя с помощью прохода по такому циклу, однозначно кратчайшее расстояние определить нельзя.
1. Форд-Беллман может работать быстрее, чем Дейкстра, на разреженных графах и/или на графах с маленьким N. У Ф-Б проще код, следовательно, меньше константы, но по асимптотике он уступает Дейкстре.
1. Честно говоря, вообще не вижу принципиальной разницы между рекурсивным и итеративным DFS. Список в качестве стека применять удобно и эффективно, потому что добавляем мы элементы в конец, а доставать их с конца удобно. Соответственно, список в качестве очереди - это уже неоптимально, т.к. доставать приходится из начала списка, а для этого нужно передвигать индексы всех остальных элементов.


on a side note: у вас очень приятные записи семинаров получаются, спасибо)